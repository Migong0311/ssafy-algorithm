T = int(input())  # 지도 개수 입력

for t in range(1, T + 1):
    N, M = map(int, input().split())  # 지도의 크기 입력
    arr = [list(map(int, input().split())) for _ in range(N)]  # 지도의 N*M 크기의 배열 입력

    grid = [[0, -1], [-1, 0], [0, 1], [1, 0]]  # 상하좌우 설정
    """
    ❌ 문제 1:
    grid는 상하좌우 방향 벡터를 나타내려는 의도인 것 같지만,
    현재 2x2 형태로 되어 있어서 방향 4개를 올바르게 표현하지 못함.
    방향 벡터는 [( -1, 0 ), ( 1, 0 ), ( 0, -1 ), ( 0, 1 )] 이런 식의 튜플 리스트여야 함.
    """

    max_high = 0  # 가장 높은 지역 초기화

    for i in range(1, N + 1):
        """
        ❌ 문제 2:
        answer, j 반복을 1부터 N/M까지 돌고 있음.
        파이썬에서 인덱스는 0부터 시작하므로 이 경우
        실제 arr의 0행, 0열은 검사조차 하지 않게 되고,
        마지막에 인덱스 범위 초과(IndexError) 위험이 있음.
        """

        for j in range(1, M + 1):  # 지도의 열과 행 순환
            max_high = grid[i][j]  # 시작점 초기화
            """
            ❌ 문제 3:
            max_high는 '가장 높은 지역 개수'를 세는 변수인데
            여기서 grid[answer][j] 값(방향 벡터)을 덮어쓰고 있음.
            이건 의미도 맞지 않고 변수 역할도 깨짐.
            """

            for di in range(N):
                for dj in range(M):  # 지도 크기자세히 순환
                    ri, rj = arr[di] + grid[i], arr[dj] + grid[j]
                    """
                    ❌ 문제 4:
                    arr[di]는 리스트(행 전체)인데 여기에 grid[answer](리스트) 더하기 연산을 하고 있음.
                    이건 두 리스트를 합치는 연산이 되어버려서, 
                    의도한 '좌표 이동'이 전혀 수행되지 않음.
                    올바른 방식은 ri = di + grid[d][0], rj = dj + grid[d][1] 형태여야 함.
                    """

                    if 0 <= ri < N and 0 <= rj < M:  # 범위값 검증
                        max_high = grid[ri][rj]  # 가장 높은 것 할당
                        """
                        ❌ 문제 5:
                        여기서도 max_high에 '방향 벡터'를 할당하고 있음.
                        실제로는 arr[ri][rj]의 높이 값을 비교해야 하고,
                        max_high는 '조건을 만족하는 지역 개수'를 세는 방식으로 업데이트해야 함.
                        """

        print(f'#{t} {max_high}')  # 출력 형식에 맞게 설정
        """
        ❌ 문제 6:
        현재 로직대로면 max_high가 마지막 갱신된 방향 벡터(혹은 리스트) 값이 출력됨.
        원래 문제 요구사항은 '안전한 지역의 개수'를 출력하는 것이므로 전혀 다른 값이 나올 것임.
        """
