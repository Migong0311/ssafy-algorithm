'''
상자들이 쌓여있는 방이 있다. 방이 오른쪽으로 90도 회전하여 상자들이 중력의 영향을 받아 낙하한다고 할 때, 낙차가 가장 큰 상자를 구하여 그 낙차를 출력 하는 프로그램을 작성하시오.



•중력은 회전이 완료된 후 적용된다.
•상자들은 모두 한쪽 벽면에 붙여진 상태로 쌓여 2차원의 형태를 이루며 벽에서 떨어져서 쌓인 상자는 없다.
•상자의 가로, 세로 길이는 각각 1이다.
•방의 가로길이는 최대 100이며, 세로 길이도 최대 100이다.
•즉, 상자는 최소 0, 최대 100 높이로 쌓을 수 있다.
•상자가 놓인 가로 칸의 수 N, 다음 줄에 각 칸의 상자 높이가 주어진다.
'''

N = int(input())
lst = list(map(int, input().split()))

# 0번째 상자 탑에서 최대 낙차
# 1번째 상자 탑에서 최대 낙차
# 2번째 상자 탑에서 최대 낙차
# ...
# n-1번째 상자 탑에서 최대 낙차

# 상자 탑들 중에서 낙차자 가장 큰 상자의 낙차는?
# 상자탑에서 맨 위를 재외한 나머지 상자고려 필없음
# 낙차의 최대값
max_drop = 0

# 모든 상자 탑 최대 낙차 구하기 위한 반복문
for i in range(N):
    # i번째 상자탑(i는 상자탑의 인덱스)에서 최대 낙차 구하기
    # 상자의 높이 = h -> i번째 사자탑의 높이
    h = lst[i]

    # 낙차를 구하는 식
    # 가로 칸의 수(N) - i번 상자탑과 왼쩍 벽과의 거리 (answer+1)
    # -i번 상자탑의 높이보다 같거나 큰 오른쪽에 있는 상자탑의 개수(high_count)
    # i번 상자탑에서의 최대 낙차 = N - (answer+1) - high_count

    # high_count 구하기
    high_count = 0
    # i번 상자탑의 오른쪽에 이쓴 상자탑의 높이를 전부 확인
    # 반복의 시작점과 종료점
    # i번 상자탑의 오른쪽 => answer+1
    # 끝 -> N
    # i번 오른쪽에 있는 상자탑의 번호를 j라고 하자
    for j in range(i + 1, N):
        # 이 j번 상자탑의 높이가 i번 상자탑보다 높은가?
        if lst[j] >= h:
            # 그렇다면 개수 1 증가
            high_count += 1
    # i번 상자탑에서의 최대 낙차 = N - (answer+1) - high_count
    drop = N - (i + 1) - high_count

    # 최대 낙차 비교
    if max_drop < drop:
        max_drop = drop
    # 반복 완료시 최대 낙차 출력
print(max_drop)
